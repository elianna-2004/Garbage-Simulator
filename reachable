// Implementation of reachable garbage collection which preserves all elements reachable in the heap
// and clears those that are not

use core::str;
use std::collections::HashMap;
use std::fs::File;
use std::io::{self, BufRead};
use std::path::Path;
use regex::Regex;

use crate::types::{Memory, RefCountMem};
use crate::utils::*;

pub fn reachable(stack: &Vec<Vec<u32>>, heap: &Vec<Option<(String, Vec<u32>)>>) -> Vec<u32> {
    
    // Breadth-First Traversal of Reachable Memory

    // Define "queue" and Traversal 
    let mut traverse = Vec::new();
    let mut reach= Vec::new();

    // Get [s] = elements on stack
    for vec in stack {
        for int in vec {

            // Get all elements of stack (Vector of Vectors)
            traverse.push(int.to_owned());

            // If on stack = reacheable so we add to our reach
            // Follow queue-fashion and insert to the end
            reach.push(int.to_owned());
        }
    }

    while !traverse.is_empty() {

        // Dequeue after obtaining value
        let int = traverse.get(0).unwrap().clone();
        traverse.remove(0);

        if let Some(elem) = heap.get(int as usize).unwrap(){
            // For ever adjacent elt that can be reached we add to reach
            for adj in &elem.1 {

                // Add to continue traversal path
                if !traverse.contains(&adj) && !reach.contains(&adj) {
                    traverse.insert(traverse.len(), adj.to_owned());
                }

                // Prevents adding duplicates
                if !reach.contains(&adj) {
                    reach.insert(reach.len(), adj.to_owned());
                }
            }
        }
    }

    reach
} 

pub fn mark_and_sweep(mem: &mut Memory) -> () {
    let mut ind = 0;
    let reach = reachable(&mem.stack, &mem.heap);

    for elt in &mut mem.heap {
        if !reach.contains(&ind) {
            *elt = None;
        }

        ind += 1;
    }
}
